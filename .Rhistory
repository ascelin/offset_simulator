outer_title,  col_vec = c('blue', 'mediumorchid4', 'darkgreen'), realisation_num, ylim = c(net_mn, net_mx))
plot_split_realisations(split_list[[2]], cfac_type = global_params$cfac_type_in_dev_calc, plot_type = 'developments',
legend_vec = c('Absolute Loss', 'Relative Loss'), legend_pos = 'bottomleft', eco_ind, lwd_vec, plot_title = 'Net Developments',
outer_title,   col_vec = c('blue', 'red'), realisation_num, ylim = c(net_mn, net_mx))
plot_realisation_outcomes(offset_gains = collated_realisations$summed_offset_realisations$net_outcome$standard,
dev_losses = collated_realisations$summed_dev_realisations$net_outcome$standard,
net_outcome = collated_realisations$net_realisation_gains$standard,
plot_title = 'Net Outcomes', x_lab = system_NNL_plot_object$x_lab, eco_ind, lwd_vec,
col_vec = c('darkgreen', 'red', 'black'), legend_vec = c('Offset Gains', 'Development Losses', 'Program Outcomes'), outer_title,
plot_lims = c(net_mn, net_mx))
plot_realisation_hists(collated_realisations$system_NNL_plot_object, unlist(collated_realisations$parcel_set_NNL_yrs),
unlist(collated_realisations$offsets$parcel_sums_at_offset), parcel_sum_lims = c(0, 20000),
use_parcel_sets = global_params$use_parcel_sets, parcel_set_NNL_plot_object, outer_title)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
realisations
realisations <- foreach(run_ind = 1:realisation_num) %dopar%{
run_offsets_simulation(global_params, initial_ecology, decline_rates_initial, parcels, dev_vec, banked_offset_vec)
}
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
collated_realisations$system_NNL_plot_object
collated_realisations$parcel_set_NNL_plot_object
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/generate_program_params.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
collated_realisations <- collate_realisations(realisations, global_params, dev_vec, decline_rates_initial, land_parcels = parcels$land_parcels, initial_ecology)
realisations
land_parcels = parcels$land_parcels
collated_realisations = list()
eco_dims = global_params$eco_dims
realisation_num = length(realisations)
collated_offset_realisations = collate_parcel_sets(realisations, realisation_num, collate_type = 'offsets', global_params, dev_vec, decline_rates_initial, land_parcels, initial_ecology)
collated_dev_realisations = collate_parcel_sets(realisations, realisation_num, collate_type = 'developments', global_params, dev_vec, decline_rates_initial, land_parcels, initial_ecology)
collate_parcel_sets(realisations, realisation_num, collate_type = 'offsets', global_params, dev_vec, decline_rates_initial, land_parcels, initial_ecology)
collate_type = 'offsets'
collated_parcel_sets = initialise_collated_realisations_object(realisation_num)
for (realisation_ind in seq_len(realisation_num)){
model_outputs = realisations[[realisation_ind]]
if (collate_type == 'offsets'){
current_model_outputs = model_outputs$offsets
cfac_type = global_params$cfac_type_in_offset_calc
adjust_cfacs_flag = global_params$adjust_offset_cfacs_flag
} else if (collate_type == 'developments'){
if ((global_params$use_offset_bank == TRUE) & (global_params$offset_bank_type == 'credit')){
current_model_outputs = model_outputs$credited_developments_object
} else{
current_model_outputs = model_outputs$developments
}
cfac_type = global_params$cfac_type_in_dev_calc
adjust_cfacs_flag = global_params$adjust_dev_cfacs_flag
}
parcel_set_indexes = unlist(current_model_outputs$parcel_indexes)
parcel_set_num = current_model_outputs$parcel_set_count
current_model_outputs$traj_list = model_outputs$traj_list[parcel_set_indexes]
time_horizons = generate_time_horizons(time_horizon_type = 'offset_bank', project_type = 'current', yr = global_params$time_steps, offset_yrs = unlist(current_model_outputs$offset_yrs),
time_horizon = (global_params$time_steps - 1), parcel_count = length(unlist(current_model_outputs$offset_yrs)))
#     time_horizons = generate_time_horizons(use_offset_bank = TRUE, time_horizon_type = 'current', yr = global_params$time_steps, offset_yrs = unlist(current_model_outputs$offset_yrs),
#                                            time_horizon = (global_params$time_steps - 1), parcel_count = length(unlist(current_model_outputs$offset_yrs)))
current_cfacs = calc_cfacs(parcel_indexes = parcel_set_indexes, parcel_ecologies = unlist(current_model_outputs$parcel_ecologies, recursive = FALSE),
parcel_num_remaining = current_model_outputs$parcel_num_remaining, global_params, dev_vec,
decline_rates_initial, time_horizons, offset_yrs = current_model_outputs$offset_yrs, cfac_type, adjust_cfacs_flag)
current_parcel_sets_object = collate_current_parcel_sets(current_model_outputs, collate_type, current_cfacs, land_parcels, time_steps = global_params$time_steps, eco_dims = global_params$eco_dims, decline_rates_initial,
parcel_set_num, cfac_type, adjust_cfacs_flag)
collated_parcel_sets <- update_parcel_sets_object(collated_parcel_sets, current_parcel_sets_object, realisation_ind, current_model_outputs$offset_yrs, parcel_set_num)
}
realisation_ind
current_cfacs
current_parcel_sets_object = collate_current_parcel_sets(current_model_outputs, collate_type, current_cfacs, land_parcels, time_steps = global_params$time_steps, eco_dims = global_params$eco_dims, decline_rates_initial,
parcel_set_num, cfac_type, adjust_cfacs_flag)
collate_type
current_model_outputs
parcel_sets_object = list()
parcel_num = length(unlist(current_model_outputs$parcel_indexes))
gains_degs_object <- collate_gains_degs(current_model_outputs, collate_type, current_model_outputs$traj_list, current_cfacs$cfacs, parcel_num, eco_dims, time_steps)
rest_gains <- combine_to_parcel_set(gains_degs_object$rest_gains, current_model_outputs$parcel_indexes, parcel_set_num, time_steps, eco_dims)
avoided_degs <- combine_to_parcel_set(gains_degs_object$avoided_degs, current_model_outputs$parcel_indexes, parcel_set_num, time_steps, eco_dims)
time_steps = global_params$time_steps
parcel_sets_object = list()
parcel_num = length(unlist(current_model_outputs$parcel_indexes))
gains_degs_object <- collate_gains_degs(current_model_outputs, collate_type, current_model_outputs$traj_list, current_cfacs$cfacs, parcel_num, eco_dims, time_steps)
rest_gains <- combine_to_parcel_set(gains_degs_object$rest_gains, current_model_outputs$parcel_indexes, parcel_set_num, time_steps, eco_dims)
avoided_degs <- combine_to_parcel_set(gains_degs_object$avoided_degs, current_model_outputs$parcel_indexes, parcel_set_num, time_steps, eco_dims)
gains_degs_object <- collate_gains_degs(current_model_outputs, collate_type, current_model_outputs$traj_list, current_cfacs$cfacs, parcel_num, eco_dims, time_steps)
traj_list  = current_model_outputs$traj_list
cfac_list = current_cfacs$cfacs
rest_gains = vector('list', eco_dims)
for (parcel_count_ind in 1:parcel_num){
rest_gains[[parcel_count_ind]] = vector('list', eco_dims)
for (eco_ind in 1:eco_dims){
rest_gains[[parcel_count_ind]][[eco_ind]] = array(0, time_steps)
}
}
avoided_degs = rest_gains       # initialise array to store rest. gains / avoided degs
offset_yrs = current_model_outputs$offset_yrs                         # vector containing year offset was initialised
if (class(offset_yrs) == 'list'){
offset_yrs = unlist(offset_yrs)
}
parcel_ecologies = unlist(current_model_outputs$parcel_ecologies, recursive = FALSE)
parcel_ecologies
for (parcel_count_ind in seq_len(parcel_num)){                      #cycle through all parcels to collate
current_yr = offset_yrs[parcel_count_ind]                         #select current offset year
for (eco_ind in seq_len(global_params$eco_dims)){                 # cycle through ecological dimensions
current_parcel_ecology = parcel_ecologies[[parcel_count_ind]]
current_parcel_traj = traj_list[[parcel_count_ind]][[eco_ind]][, , current_yr:time_steps]
current_parcel_cfac = cfac_list[[parcel_count_ind]][[eco_ind]]
current_gains_degs <- separate_gains_degs(current_parcel_traj, collate_type, current_parcel_cfac, current_parcel_ecology)
rest_gains[[parcel_count_ind]][[eco_ind]][current_yr:time_steps] = current_gains_degs$gains
avoided_degs[[parcel_count_ind]][[eco_ind]][current_yr:time_steps] = current_gains_degs$degs
}
}
current_parcel_ecology = parcel_ecologies[[parcel_count_ind]]
current_parcel_traj = traj_list[[parcel_count_ind]][[eco_ind]][, , current_yr:time_steps]
current_parcel_cfac = cfac_list[[parcel_count_ind]][[eco_ind]]
current_gains_degs <- separate_gains_degs(current_parcel_traj, collate_type, current_parcel_cfac, current_parcel_ecology)
current_parcel_traj
current_yr
dim(current_parcel_traj)
collate_gains_degs <- function(current_model_outputs, collate_type, traj_list, cfac_list, parcel_num, eco_dims, time_steps){
rest_gains = vector('list', eco_dims)
for (parcel_count_ind in 1:parcel_num){
rest_gains[[parcel_count_ind]] = vector('list', eco_dims)
for (eco_ind in 1:eco_dims){
rest_gains[[parcel_count_ind]][[eco_ind]] = array(0, time_steps)
}
}
avoided_degs = rest_gains       # initialise array to store rest. gains / avoided degs
offset_yrs = current_model_outputs$offset_yrs                         # vector containing year offset was initialised
if (class(offset_yrs) == 'list'){
offset_yrs = unlist(offset_yrs)
}
parcel_ecologies = unlist(current_model_outputs$parcel_ecologies, recursive = FALSE)        #remove lowest list level
for (parcel_count_ind in seq_len(parcel_num)){                      #cycle through all parcels to collate
current_yr = offset_yrs[parcel_count_ind]                         #select current offset year
for (eco_ind in seq_len(global_params$eco_dims)){                 # cycle through ecological dimensions
current_parcel_ecology = parcel_ecologies[[parcel_count_ind]]
current_parcel_traj = traj_list[[parcel_count_ind]][[eco_ind]][, , current_yr:time_steps]
current_parcel_cfac = cfac_list[[parcel_count_ind]][[eco_ind]]
if (length(dim(current_parcel_traj)) > 2){
current_gains_degs <- separate_gains_degs(current_parcel_traj, collate_type, current_parcel_cfac, current_parcel_ecology)
rest_gains[[parcel_count_ind]][[eco_ind]][current_yr:time_steps] = current_gains_degs$gains
avoided_degs[[parcel_count_ind]][[eco_ind]][current_yr:time_steps] = current_gains_degs$degs
}
}
}
collate_object = list()
collate_object$rest_gains = rest_gains
collate_object$avoided_degs = avoided_degs
return(collate_object)
}
parcel_sets_object = list()
parcel_num = length(unlist(current_model_outputs$parcel_indexes))
gains_degs_object <- collate_gains_degs(current_model_outputs, collate_type, current_model_outputs$traj_list, current_cfacs$cfacs, parcel_num, eco_dims, time_steps)
gains_degs_object
parcel_sets_object = list()
parcel_num = length(unlist(current_model_outputs$parcel_indexes))
gains_degs_object <- collate_gains_degs(current_model_outputs, collate_type, current_model_outputs$traj_list, current_cfacs$cfacs, parcel_num, eco_dims, time_steps)
rest_gains <- combine_to_parcel_set(gains_degs_object$rest_gains, current_model_outputs$parcel_indexes, parcel_set_num, time_steps, eco_dims)
avoided_degs <- combine_to_parcel_set(gains_degs_object$avoided_degs, current_model_outputs$parcel_indexes, parcel_set_num, time_steps, eco_dims)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
collated_realisations$parcel_set_NNL_yrs
collated_realisations$parcel_set_NNL_plot_object
collated_realisations$parcel_set_NNL_plot_object$NNL_failed
collated_realisations$parcel_set_NNL_plot_object$NNL_failedsource('collate_routines.R')
source('collate_routines.R')
source('collate_routines.R')
collated_realisations <- collate_realisations(realisations, global_params, dev_vec, decline_rates_initial, land_parcels = parcels$land_parcels, initial_ecology)
source('collate_routines.R')
collated_realisations <- collate_realisations(realisations, global_params, dev_vec, decline_rates_initial, land_parcels = parcels$land_parcels, initial_ecology)
collated_realisations$parcel_set_NNL_plot_object
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
plot_parcel_sets <- function(collated_realisations, realisation_num, eco_ind, col_list, legend_loc){
realisation_ind = sample(realisation_num, 1)
parcel_set_num = collated_realisations$devs$parcel_set_num[[realisation_ind]]
parcel_set_eg = sample(parcel_set_num, 3)
for (parcel_set_ind in parcel_set_eg){
offset_parcel_set = collate_parcel_set_element(gains = collated_realisations$offsets$rest_gains[[realisation_ind]][[eco_ind]][, parcel_set_ind],
degs = collated_realisations$offsets$avoided_degs[[realisation_ind]][[eco_ind]][, parcel_set_ind])
dev_parcel_set = collate_parcel_set_element(gains = collated_realisations$devs$rest_gains[[realisation_ind]][[eco_ind]][, parcel_set_ind],
degs = collated_realisations$devs$avoided_degs[[realisation_ind]][[eco_ind]][, parcel_set_ind])
net_parcel_set = collate_parcel_set_element(gains = offset_parcel_set$nets, degs = dev_parcel_set$nets)
mn = min(unlist(list(offset_parcel_set, dev_parcel_set)))
mx = max(unlist(list(offset_parcel_set, dev_parcel_set)))
overlay_plot_list(plot_list = offset_parcel_set, yticks = 'y', axis_lab = TRUE, ylims = c(mn, mx), heading = 'Offset', ylab = '', col_vec = col_list[[1]], lty_vec = c(1, 1, 2),
lwd_vec = c(1, 1, 2), legend_vec = c('Restoration Gains', 'Avoided Degredation', 'Relative Gains'), legend_loc)
overlay_plot_list(plot_list = dev_parcel_set[c(1, 3)], yticks = 'y', axis_lab = TRUE, ylims = c(mn, mx), heading = 'Development', ylab = '', col_vec = col_list[[2]][c(1, 3)], lty_vec = c(1, 2),
lwd_vec = c(1, 2), legend_vec = c('Absolute Loss', 'Relative Loss'), legend_loc)
overlay_plot_list(plot_list = net_parcel_set, yticks = 'y', axis_lab = TRUE, ylims = c(mn, mx), heading = 'Net Outcome', ylab = '', col_vec = col_list[[3]], lty_vec = c(2, 2, 1),
lwd_vec= c(2, 2, 3), legend_vec = c('Relative Offset Gains', 'Relative Development Losses', 'Net Outcomes'), legend_loc)
}
}
graphics.off()
plot_collated_realisations(collated_realisations, realisation_num = length(realisations), global_params, parcel_sum_lims = c(0, 20000), eco_ind = 1, lwd_vec = c(3, 0.15), outer_title = plot_characteristics)
plot_landscape_outcomes <- function(landscape_realisations, plot_type, plot_title, loss_object, realisation_num, cfacs, eco_ind, lwd_vec, col_vec, legend_vec, outer_title, time_steps){
loss_tit = paste('Net Loss at ', time_steps, 'yrs = ', round(mean(loss_object$total_loss)*100), '%')
if (length(loss_object$NNL_loss) > 0){
NNL_tit = paste('NNL at ', round(mean(loss_object$NNL_loss*100)), '% landscape loss')
} else NNL_tit = 'All realisations failed NNL'
sub_tit = cbind(NNL_tit, loss_tit)
plot_collated_realisation_set(landscape_realisations, overlay_plots = FALSE, plot_col = col_vec[1], realisation_num, eco_ind, lwd_vec,
x_lab = sub_tit, plot_title = plot_title, plot_lims = vector())
if (plot_type == 'program'){
plot_collated_realisation_set(cfacs, overlay_plots = TRUE, plot_col = col_vec[2], realisation_num, eco_ind, lwd_vec,
x_lab = '', plot_title = '', plot_lims = vector())
} else {
lines(cfacs[[eco_ind]], col = col_vec[2], lty = 2, lwd = 2)
}
#abline(h = mean(landscape_realisations[1, , ]), lty = 2)
legend('topright', legend_vec, bty="n", lty = c(2, 2), lwd = array(lwd_vec[1], 2), col = col_vec[1:2])
title(outer_title, outer = TRUE)
}
plot_collated_realisations(collated_realisations, realisation_num = length(realisations), global_params, parcel_sum_lims = c(0, 20000), eco_ind = 1, lwd_vec = c(3, 0.15), outer_title = plot_characteristics)
decline_rates_initial
mean(decline_rates_initial)
predict_parcel_traj <- function(current_parcel_ecology, current_parcel_ind, eco_ind, parcel_traj_type, global_params, decline_rates, time_horizon){
time_fill = TRUE
eco_dims = global_params$eco_dims
projected_ecology = vector('list', eco_dims)
if (parcel_traj_type == 'protect'){
dec_rate = find_decline_rate(decline_rates, current_parcel_ind, eco_ind)
} else if (parcel_traj_type == 'maintain'){
dec_rate = 1e-10
} else if (parcel_traj_type == 'restore'){
dec_rate = global_params$restoration_rate
}
# current_predicted_ecology = apply(current_slice, MARGIN = c(1, 2), FUN = project_ecology, min_eco_val = global_params$min_eco_val, max_eco_val = global_params$max_eco_val, dec_rate, time_horizon, time_fill)
if (time_horizon > 0){
if (dec_rate < 0){
current_predicted_ecology = sapply(current_parcel_ecology, project_ecology, min_eco_val = global_params$min_eco_val, max_eco_val = global_params$max_eco_val, decline_rate = dec_rate, time_horizon = time_horizon, time_fill)  # update ecology according to ecological curve in project_ecology function (currently logistic) - curve parameters are contained in decline_rates array
} else if ( dec_rate > 0){
current_predicted_ecology = sapply(current_parcel_ecology, project_ecology, min_eco_val = global_params$min_eco_val, max_eco_val = global_params$max_restoration_eco_val, decline_rate = dec_rate, time_horizon = time_horizon, time_fill)  # update ecology according to ecological curve in project_ecology function (currently logistic) - curve parameters are contained in decline_rates array
}
dim(current_predicted_ecology) = c(dim(current_predicted_ecology), 1)
current_predicted_ecology = aperm(current_predicted_ecology, c(3, 2, 1))
dim(current_predicted_ecology) = c(dim(current_parcel_ecology), (time_horizon + 1))
} else{
current_predicted_ecology = current_parcel_ecology
dim(current_predicted_ecology) = c(dim(current_parcel_ecology), 1)
}
projected_ecology = current_predicted_ecology
return(projected_ecology)
}
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
current_ecology = initial_ecology
decline_rates = decline_rates_initial
trajectories <- initialise_trajectories(global_params$eco_dims, global_params$ecology_size, global_params$time_steps, initial_ecologies)    # initialise trajectories as a list of N 3D arrays to fill for each eco dimension
offsets_object <- initialise_parcel_set_object()   #initialise offsets object to store all offsets
developments_object <- initialise_developments_object(dev_vec) #initialise developments object to store all offsets
banked_offsets_object <- initialise_banked_offsets_object(global_params, banked_offset_vec)
index_object <- initialise_index_object(parcels, global_params)
credited_developments_object <- initialise_parcel_set_object()
dev_credit = 0
decline_rates = decline_rates_initial
for (yr in seq_len(global_params$time_steps)){          #run through main time loop
current_dev_nums <- find_current_dev_nums(developments_object$dev_vec, global_params$region_num, yr) #developments to perform in current year per region
time_horizon <- assess_time_horizon(global_params$use_offset_time_horizon, global_params$offset_time_horizon, global_params$time_steps, yr)   # determine whetehr time horizons to use in calcs are till simulation end or user provided length of time
for (region_ind in seq_len(parcels$region_num)){            #cycle through each region
if (global_params$use_offset_bank == TRUE){               # perform offset banking routine if selected
offset_bank_num = banked_offsets_object$banked_offset_vec[yr]   # how many offsets to be added in current year
if (offset_bank_num > 0){
print( banked_offsets_object$bank_num)
total_current_pool = index_object$ind_available[[region_ind]]             # determine parcel indexes currently available
index_object$parcel_num_remaining = length(total_current_pool)            # record how many parcels remaining
current_banked_offset_pool <- select_banked_offset_indexes(offset_bank_num, total_current_pool)   # select current number of offset parcels from current available pool to add to banked offset pool
current_banked_offset <- record_current_parcel_set(land_parcels = parcels$land_parcels, current_ecology, current_pool = current_banked_offset_pool,
parcel_num_remaining = index_object$parcel_num_remaining, yr)   # arrange current parcel data
banked_offsets_object <- update_banked_offsets(banked_offsets_object, current_banked_offset)      #record current parcel data into banked offset object
index_object <- update_banked_offset_pool(index_object, current_banked_offset_pool)   # add new offset parcels to banked offset pool
index_object <- update_ind_available(update_type = 'offset', index_object, current_banked_offset_pool, region_ind) #remove selected offest parcels from avilable pool
decline_rates <- update_decline_rates(decline_rates, global_params, decline_rate_type = 'offset', current_banked_offset_pool) # update decline rate for current banked offset parcels
}
}
current_develop_num = current_dev_nums[region_ind]        # how many parcels to be developed in current year
if (current_develop_num > 0) {
for (parcel_set_count_index in seq_len(current_develop_num)){   # cycle through number of developments and associated offsets
if (global_params$use_offset_bank == TRUE){
current_offset_pool = index_object$banked_offset_pool       # available pool when using offset banking
if (length(current_offset_pool) == 0){break}              #break out when no parcels are left in banking pool
offset_pool_object <- prepare_offset_bank(banked_offsets_object, current_offset_pool, restoration_flag = global_params$offset_restoration_flag,
parcels$land_parcels, current_ecology, eco_dims = global_params$eco_dims)   #arrange current banked offset data into form to use in parcel set determination
offset_pool_type = 'offset_bank'
} else {
current_offset_pool = index_object$ind_available[[region_ind]]
parcel_num_remaining = length(current_offset_pool)
offset_pool_object <- record_current_parcel_set(land_parcels = parcels$land_parcels, current_ecology, current_offset_pool, parcel_num_remaining, yr)   #arrange available parcel pool into form to use in parcel set determination
offset_pool_type = 'offsets'
}
offset_pool_object <- assess_current_pool(pool_object = offset_pool_object, pool_type = offset_pool_type, calc_type = global_params$offset_calc_type, cfacs_flag = global_params$offset_cfacs_flag,
adjust_cfacs_flag = global_params$adjust_offset_cfacs_flag, cfac_type = global_params$cfac_type_in_offset_calc, time_horizon_type = global_params$offset_time_horizon_type,
global_params, dev_vec = developments_object$dev_vec, decline_rates_initial, time_horizon, yr)      #determine available parcel values, depending on what particular offset policy is in use using counterfactuals etc.
if (global_params$use_dev_credit == TRUE){
if (global_params$use_offset_bank == TRUE){
net_development_val = sum(unlist(developments_object$parcel_vals_used))
current_pool_vals = unlist(offset_pool_object$parcel_vals_used)
dev_credit = sum(current_pool_vals) - net_development_val
}
current_development_object = develop_from_credit(dev_credit, global_params, dev_vec = developments_object$dev_vec, ind_available = index_object$ind_available[[region_ind]], current_ecology, decline_rates_initial,
land_parcels = parcels$land_parcels, yr, time_horizon)
dev_credit = current_development_object$dev_credit
if (current_development_object$match_flag == TRUE){
index_object$credited_parcel_set_count = index_object$credited_parcel_set_count + 1
}
} else {
current_development_object = list()
current_development_object$match_flag = FALSE
}
parcel_set_flag = ((current_development_object$match_flag == FALSE) & (global_params$use_parcel_sets == TRUE))
if (parcel_set_flag == TRUE){  #if insufficient credits accumulated, perform offset parcel set match
if (length(index_object$ind_available[[region_ind]]) > 0){
matched_parcel_set_object <- match_parcel_set(offset_pool_object, dev_credit, global_params, dev_vec = developments_object$dev_vec, ind_available = index_object$ind_available[[region_ind]],
current_ecology, decline_rates_initial, parcels$land_parcels, yr, time_horizon)  #perform the matching routine - i.e. find a matching development/offset set.
} else{
break
}
current_development_object = matched_parcel_set_object$current_development_object
if (current_development_object$match_flag == TRUE){
index_object$parcel_set_count = index_object$parcel_set_count + 1
current_offset_object <- matched_parcel_set_object$offset_object
current_offset_indexes = current_offset_object$parcel_indexes
if (global_params$use_offset_bank == TRUE){
banked_offset_inds_used = list_intersect(index_object$banked_offset_pool, current_offset_indexes)         # when using offset banking determine parcels used in matching routine and remove from available pool
banked_offset_inds_used = banked_offset_inds_used$match_ind
index_object$banked_offset_pool = index_object$banked_offset_pool[-banked_offset_inds_used]
} else {
index_object = update_ind_available(update_type = 'offset', index_object, current_offset_indexes, region_ind)         # determine parcels used in matching routine and remove from available pool
decline_rates <- update_decline_rates(decline_rates, global_params, decline_rate_type = 'offset', current_offset_indexes) # set elements in decline rates array corresponding to offsets to restoration rates
}
offsets_object <- write_current_parcel_set(offsets_object, current_offset_object, index_object$parcel_set_count)      #record current offset parcels in offsets object containing all offsets info
}
}
if (current_development_object$match_flag == TRUE){
current_dev_indexes = current_development_object$parcel_indexes
index_object = update_ind_available(update_type = 'development', index_object, current_dev_indexes, region_ind)                 #remove development parcels from available pool
decline_rates <- update_decline_rates(decline_rates, global_params, decline_rate_type = 'development', current_dev_indexes)     # set elements corresponding to developed parcels in decline rates array to zero.
if (global_params$use_parcel_sets){
developments_object <- write_current_parcel_set(developments_object, current_development_object, index_object$parcel_set_count)  # record development info for current parcel set into object containing all development info
} else {
credited_developments_object = write_current_parcel_set(credited_developments_object, current_development_object, parcel_set_count = index_object$credited_parcel_set_count)
}
dev_credit = current_development_object$dev_credit
}
}
}
for (eco_ind in seq_len(global_params$eco_dims)){
trajectories[[eco_ind]][, , yr] = current_ecology[, , eco_ind] # record current ecology in trajectories list for each eco dimension
}
current_ecology <- project_current_system(current_ecology, parcels$land_parcels, decline_rates, global_params$min_eco_val, global_params$max_eco_val,
global_params$max_restoration_eco_val, time_horizon = 1, global_params$eco_dims)     # update ecology for subsequent time step using current decline rates
}
print(yr)
}
project_current_system <- function(current_ecology, land_parcels, decline_rates, min_eco_val, max_eco_val, max_restoration_eco_val, time_horizon, eco_dims){
parcel_num = length(land_parcels)
for (eco_ind in seq_len(eco_dims)){
current_ecology_slice = current_ecology[, , eco_ind] #select current ecological dimension to work on
current_decline_rates = decline_rates[,  , eco_ind] #select current decline rates to work on
for (parcel_ind in seq_len(parcel_num)){
current_parcel = select_land_parcel(land_parcels, parcel_ind)   #select array indexes that correspond to current land parcel
current_parcel_ecology = current_ecology[current_parcel]
decline_rate = current_decline_rates[parcel_ind] #select corresponding decline rate
if (decline_rate == 0){
updated_parcel_ecology = array(0, length(current_parcel_ecology))   # if the parcel is to be developed (i.e. decline rate = 0), set parcel value to zeros
} else if (decline_rate == 1){
updated_parcel_ecology = current_parcel_ecology      # if the parcel is to be maintained (i.e. decline rate = 1), set parcel values to current values
} else {
if (decline_rate < 0){
updated_parcel_ecology = sapply(current_parcel_ecology, project_ecology, min_eco_val = min_eco_val,
max_eco_val = max_eco_val, decline_rate = decline_rate, time_horizon = time_horizon, time_fill = FALSE)
} else if (decline_rate > 0){
updated_parcel_ecology = sapply(current_parcel_ecology, project_ecology, min_eco_val = min_eco_val,
max_eco_val = max_restoration_eco_val, decline_rate = decline_rate, time_horizon = time_horizon, time_fill = FALSE)
}
}# update ecology according to ecological curve in project_ecology function (currently logistic) - curve parameters are contained in decline_rates array
current_ecology_slice[current_parcel] = updated_parcel_ecology
}
current_ecology[, , eco_ind]  = current_ecology_slice
}
return(current_ecology)
}
current_ecology = initial_ecology
decline_rates = decline_rates_initial
trajectories <- initialise_trajectories(global_params$eco_dims, global_params$ecology_size, global_params$time_steps, initial_ecologies)    # initialise trajectories as a list of N 3D arrays to fill for each eco dimension
offsets_object <- initialise_parcel_set_object()   #initialise offsets object to store all offsets
developments_object <- initialise_developments_object(dev_vec) #initialise developments object to store all offsets
banked_offsets_object <- initialise_banked_offsets_object(global_params, banked_offset_vec)
index_object <- initialise_index_object(parcels, global_params)
credited_developments_object <- initialise_parcel_set_object()
dev_credit = 0
decline_rates = decline_rates_initial
for (yr in seq_len(global_params$time_steps)){          #run through main time loop
current_dev_nums <- find_current_dev_nums(developments_object$dev_vec, global_params$region_num, yr) #developments to perform in current year per region
time_horizon <- assess_time_horizon(global_params$use_offset_time_horizon, global_params$offset_time_horizon, global_params$time_steps, yr)   # determine whetehr time horizons to use in calcs are till simulation end or user provided length of time
for (region_ind in seq_len(parcels$region_num)){            #cycle through each region
if (global_params$use_offset_bank == TRUE){               # perform offset banking routine if selected
offset_bank_num = banked_offsets_object$banked_offset_vec[yr]   # how many offsets to be added in current year
if (offset_bank_num > 0){
print( banked_offsets_object$bank_num)
total_current_pool = index_object$ind_available[[region_ind]]             # determine parcel indexes currently available
index_object$parcel_num_remaining = length(total_current_pool)            # record how many parcels remaining
current_banked_offset_pool <- select_banked_offset_indexes(offset_bank_num, total_current_pool)   # select current number of offset parcels from current available pool to add to banked offset pool
current_banked_offset <- record_current_parcel_set(land_parcels = parcels$land_parcels, current_ecology, current_pool = current_banked_offset_pool,
parcel_num_remaining = index_object$parcel_num_remaining, yr)   # arrange current parcel data
banked_offsets_object <- update_banked_offsets(banked_offsets_object, current_banked_offset)      #record current parcel data into banked offset object
index_object <- update_banked_offset_pool(index_object, current_banked_offset_pool)   # add new offset parcels to banked offset pool
index_object <- update_ind_available(update_type = 'offset', index_object, current_banked_offset_pool, region_ind) #remove selected offest parcels from avilable pool
decline_rates <- update_decline_rates(decline_rates, global_params, decline_rate_type = 'offset', current_banked_offset_pool) # update decline rate for current banked offset parcels
}
}
current_develop_num = current_dev_nums[region_ind]        # how many parcels to be developed in current year
if (current_develop_num > 0) {
for (parcel_set_count_index in seq_len(current_develop_num)){   # cycle through number of developments and associated offsets
if (global_params$use_offset_bank == TRUE){
current_offset_pool = index_object$banked_offset_pool       # available pool when using offset banking
if (length(current_offset_pool) == 0){break}              #break out when no parcels are left in banking pool
offset_pool_object <- prepare_offset_bank(banked_offsets_object, current_offset_pool, restoration_flag = global_params$offset_restoration_flag,
parcels$land_parcels, current_ecology, eco_dims = global_params$eco_dims)   #arrange current banked offset data into form to use in parcel set determination
offset_pool_type = 'offset_bank'
} else {
current_offset_pool = index_object$ind_available[[region_ind]]
parcel_num_remaining = length(current_offset_pool)
offset_pool_object <- record_current_parcel_set(land_parcels = parcels$land_parcels, current_ecology, current_offset_pool, parcel_num_remaining, yr)   #arrange available parcel pool into form to use in parcel set determination
offset_pool_type = 'offsets'
}
offset_pool_object <- assess_current_pool(pool_object = offset_pool_object, pool_type = offset_pool_type, calc_type = global_params$offset_calc_type, cfacs_flag = global_params$offset_cfacs_flag,
adjust_cfacs_flag = global_params$adjust_offset_cfacs_flag, cfac_type = global_params$cfac_type_in_offset_calc, time_horizon_type = global_params$offset_time_horizon_type,
global_params, dev_vec = developments_object$dev_vec, decline_rates_initial, time_horizon, yr)      #determine available parcel values, depending on what particular offset policy is in use using counterfactuals etc.
if (global_params$use_dev_credit == TRUE){
if (global_params$use_offset_bank == TRUE){
net_development_val = sum(unlist(developments_object$parcel_vals_used))
current_pool_vals = unlist(offset_pool_object$parcel_vals_used)
dev_credit = sum(current_pool_vals) - net_development_val
}
current_development_object = develop_from_credit(dev_credit, global_params, dev_vec = developments_object$dev_vec, ind_available = index_object$ind_available[[region_ind]], current_ecology, decline_rates_initial,
land_parcels = parcels$land_parcels, yr, time_horizon)
dev_credit = current_development_object$dev_credit
if (current_development_object$match_flag == TRUE){
index_object$credited_parcel_set_count = index_object$credited_parcel_set_count + 1
}
} else {
current_development_object = list()
current_development_object$match_flag = FALSE
}
parcel_set_flag = ((current_development_object$match_flag == FALSE) & (global_params$use_parcel_sets == TRUE))
if (parcel_set_flag == TRUE){  #if insufficient credits accumulated, perform offset parcel set match
if (length(index_object$ind_available[[region_ind]]) > 0){
matched_parcel_set_object <- match_parcel_set(offset_pool_object, dev_credit, global_params, dev_vec = developments_object$dev_vec, ind_available = index_object$ind_available[[region_ind]],
current_ecology, decline_rates_initial, parcels$land_parcels, yr, time_horizon)  #perform the matching routine - i.e. find a matching development/offset set.
} else{
break
}
current_development_object = matched_parcel_set_object$current_development_object
if (current_development_object$match_flag == TRUE){
index_object$parcel_set_count = index_object$parcel_set_count + 1
current_offset_object <- matched_parcel_set_object$offset_object
current_offset_indexes = current_offset_object$parcel_indexes
if (global_params$use_offset_bank == TRUE){
banked_offset_inds_used = list_intersect(index_object$banked_offset_pool, current_offset_indexes)         # when using offset banking determine parcels used in matching routine and remove from available pool
banked_offset_inds_used = banked_offset_inds_used$match_ind
index_object$banked_offset_pool = index_object$banked_offset_pool[-banked_offset_inds_used]
} else {
index_object = update_ind_available(update_type = 'offset', index_object, current_offset_indexes, region_ind)         # determine parcels used in matching routine and remove from available pool
decline_rates <- update_decline_rates(decline_rates, global_params, decline_rate_type = 'offset', current_offset_indexes) # set elements in decline rates array corresponding to offsets to restoration rates
}
offsets_object <- write_current_parcel_set(offsets_object, current_offset_object, index_object$parcel_set_count)      #record current offset parcels in offsets object containing all offsets info
}
}
if (current_development_object$match_flag == TRUE){
current_dev_indexes = current_development_object$parcel_indexes
index_object = update_ind_available(update_type = 'development', index_object, current_dev_indexes, region_ind)                 #remove development parcels from available pool
decline_rates <- update_decline_rates(decline_rates, global_params, decline_rate_type = 'development', current_dev_indexes)     # set elements corresponding to developed parcels in decline rates array to zero.
if (global_params$use_parcel_sets){
developments_object <- write_current_parcel_set(developments_object, current_development_object, index_object$parcel_set_count)  # record development info for current parcel set into object containing all development info
} else {
credited_developments_object = write_current_parcel_set(credited_developments_object, current_development_object, parcel_set_count = index_object$credited_parcel_set_count)
}
dev_credit = current_development_object$dev_credit
}
}
}
for (eco_ind in seq_len(global_params$eco_dims)){
trajectories[[eco_ind]][, , yr] = current_ecology[, , eco_ind] # record current ecology in trajectories list for each eco dimension
}
current_ecology <- project_current_system(current_ecology, parcels$land_parcels, decline_rates, global_params$min_eco_val, global_params$max_eco_val,
global_params$max_restoration_eco_val, time_horizon = 1, global_params$eco_dims)     # update ecology for subsequent time step using current decline rates
}
print(yr)
}
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
graphics.off()
image(realisations[[1]]$trajectories[[1]][[1]][, , 1])
image(realisations[[1]]$trajectories[[1]][[1]][[1]][, , 1])
realisations[[1]]$trajectories[[1]][[1]]
image(realisations[[1]]$trajectories[[1]][, , 1])
image(realisations[[1]]$trajectories[[1]][, , 50])
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs.R', echo=TRUE)
