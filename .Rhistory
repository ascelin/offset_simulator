global_params,
time_horizon,
yr)
}
for (current_dev_index in seq_len(current_program_params$intervention_vec[yr])){   # cycle through number of developments and associated offsets
if (current_program_params$use_dev_credit == TRUE){
global_object$dev_credit_to_use = assess_credit(global_object, current_program_params)
global_object$credit_match_object = develop_from_credit(global_object$current_ecology,
global_object$dev_credit_to_use,
dev_weights,
global_params,
current_program_params,
intervention_vec = current_program_params$intervention_vec,
dev_ind_available = global_object$index_object$ind_available[[region_ind]],
decline_rates_initial,
global_object$land_parcels,
region_ind,
yr,
time_horizon)
if (global_object$credit_match_object$match_flag == TRUE){
#stopifnot(global_object$credit_match_object$match_flag == FALSE)
global_object$dev_credit = global_object$credit_match_object$dev_credit
print(paste('credit flag ', global_object$credit_match_object$match_vals))
global_object <- perform_clearing_routine(global_object,
clearing_type = 'develop_from_credit',
current_development_object = global_object$credit_match_object$development_object,
region_ind,
global_params)
}
}
if ( (global_object$credit_match_object$match_flag == FALSE && current_program_params$use_parcel_sets == TRUE)){  #if insufficient credits accumulated, perform offset parcel set match
print('matching parcel sets')
global_object$match_object <- match_parcel_set(offset_pool_object = global_object$offset_pool_object,
global_object$dev_credit_to_use,
dev_weights,
global_params,
current_program_params,
intervention_vec = current_program_params$intervention_vec,
ind_available = global_object$index_object$ind_available[[region_ind]],
global_object$current_ecology,
decline_rates = global_object$decline_rates,
parcels$land_parcels,
yr,
time_horizon,
region_ind)  #perform the matching routine - i.e. find a matching development/offset set.
if (global_object$match_object$match_flag == TRUE){
global_object$recorded_dev_credit = append(global_object$recorded_dev_credit, global_object$match_object$dev_credit)
global_object$dev_credit = global_object$match_object$dev_credit
global_object <- perform_offset_routine(global_object, global_object$match_object, current_program_params, region_ind, global_params)
global_object <- perform_clearing_routine(global_object,
clearing_type = 'development',
current_development_object = global_object$match_object$current_development_object,
region_ind,
global_params)
}
}
if ( (global_object$credit_match_object$match_flag == FALSE) & (global_object$match_object$match_flag == FALSE) ){
print('match break flag')
break
}
}
if (global_params$perform_illegal_clearing == TRUE){
global_object <- perform_illegal_clearing(global_object, global_object$current_ecology, land_parcel_num = parcels$land_parcel_num,
yr, region_ind, current_program_params, global_params, decline_rates_initial, time_horizon)
}
}
if ( (length(unlist(global_object$offsets_object$parcel_indexes)) > 0) &
(global_params$limit_offset_restoration == TRUE) &
current_program_params$offset_action_type == 'restore'){
assessed_parcel_sets_object <- assess_parcel_sets(global_object$current_ecology,
global_object$offsets_object,
offset_indexes = global_object$index_object$offsets,
global_params,
current_program_params,
decline_rates_initial,
time_horizon,
yr)
global_object$decline_rates <- update_decline_rates(global_object$decline_rates,
restoration_rate = current_program_params$restoration_rate,
dims_to_use = global_params$dims_to_use,
eco_dims = global_params$eco_dims,
decline_rate_type = 'offset',
offset_action_type = 'maintain',
parcel_indexes = assessed_parcel_sets_object$site_success_inds)
}
global_object$current_ecology <- kill_development_ecology(global_object$current_ecology, global_object$decline_rates, global_params$eco_dims)
global_object$trajectories <- update_trajectories(global_object$trajectories, global_params$eco_dims, global_object$current_ecology, yr)
global_object$current_ecology <- project_current_system_multi(global_object$current_ecology,
decline_rates = global_object$decline_rates,
min_eco_val = global_params$min_eco_val,
max_eco_val = global_params$max_eco_val,
max_restoration_eco_val = global_params$max_eco_val,
time_horizon = 1,
eco_dims = global_params$eco_dims)     # update ecology for subsequent time step using current decline rates
print(yr)
}
match_parcel_set <- function(offset_pool_object, dev_credit, dev_weights, global_params, current_program_params,
intervention_vec, ind_available, current_ecology, decline_rates_initial,
land_parcels, yr, time_horizon, region_ind){
match_object = list()
match_object$match_flag = FALSE
current_pool_vals = offset_pool_object$parcel_vals_used
current_pool_indexes = offset_pool_object$parcel_indexes
parcel_num_remaining = length(ind_available)
current_match_pool = ind_available
current_dev_weights = dev_weights[current_match_pool]
current_dev_weights = current_dev_weights/sum(current_dev_weights)
if (parcel_num_remaining == 0){ # exit if no parcels remain
return(match_object)
}
dev_pool_object <- record_current_parcel_set(current_ecology[current_match_pool],
current_match_pool,
parcel_num_remaining,
yr,
region_ind) #record potential current development parcel attributes
dev_pool_object <- assess_current_pool(pool_object = dev_pool_object,
pool_type = 'devs',
calc_type = current_program_params$dev_calc_type,
cfacs_flag = current_program_params$dev_cfacs_flag,
adjust_cfacs_flag = current_program_params$adjust_dev_cfacs_flag,
offset_restoration_flag = current_program_params$offset_restoration_flag,
include_potential_developments = current_program_params$include_potential_developments_in_dev_calc,
include_potential_offsets = current_program_params$include_potential_offsets_in_dev_calc,
include_illegal_clearing = current_program_params$include_illegal_clearing_in_dev_calc,
time_horizon_type = 'future',
global_params,
current_program_params,
decline_rates_initial,
time_horizon,
yr)  #determine future development parcel attributes
current_match_vals_pool = dev_pool_object$parcel_vals_used
while( (match_object$match_flag == FALSE) & length(current_match_pool > 1) ){   #any potential parcel set match requires a minimum of two sites
if (current_program_params$development_selection_type == 'random'){
sample_ind = sample(seq_along(current_match_pool), size = 1)
} else if (current_program_params$development_selection_type == 'weighted'){
sample_ind = sample(seq_along(current_match_pool), size = 1, prob = current_dev_weights)
}
current_test_index = current_match_pool[sample_ind]
vals_to_match = current_match_vals_pool[[sample_ind]]
if (current_program_params$use_offset_bank == FALSE){
dev_ind = list_intersect(current_pool_indexes, current_test_index) #find and remove index that corresponds to potiential development index
match_pool_to_use = current_pool_indexes[-dev_ind$match_ind]
vals_to_use = current_pool_vals[-dev_ind$match_ind]
} else {
match_pool_to_use = current_pool_indexes  #if performing offset banking use any of the available banked offset pool
vals_to_use = current_pool_vals
}
match_object <- select_from_pool(match_type = 'offset',
match_procedure = 'euclidean',
current_pool = match_pool_to_use,
vals_to_use,
dev_credit,
dev_weights,
use_parcel_set_dev_credit = current_program_params$use_parcel_set_dev_credit,
offset_multiplier = current_program_params$offset_multiplier,
match_threshold = global_params$match_threshold,
vals_to_match_initial = vals_to_match,
current_program_params$offset_parcel_for_parcel,
dims_to_use = global_params$dims_to_use,
max_offset_parcel_num = global_params$max_offset_parcel_num,
yr) #perform matching routine
if (match_object$match_flag == FALSE){
inds_to_keep = which(lapply(seq_along(dev_pool_object$parcel_vals_used),
function(i) all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[i]], vals_to_match)) < 0) ) == TRUE)
current_match_pool = dev_pool_object$parcel_indexes[inds_to_keep]     #remove current potential development from potential pool
current_match_vals_pool = dev_pool_object$parcel_vals_used[inds_to_keep]
print(length(current_match_pool))
print(unlist(vals_to_match))
}
}
if (match_object$match_flag == TRUE){
dev_match_index = which(unlist(dev_pool_object$parcel_indexes) == current_test_index)
match_object$current_development_object = select_subset(dev_pool_object, unlist(dev_match_index))
subset_pool =  list_intersect(offset_pool_object$parcel_indexes, match_object$match_indexes)
offset_object <- select_subset(pool_object = offset_pool_object, subset_pool = subset_pool$match_ind)
match_object$offset_object = offset_object
} else if (match_object$match_flag == FALSE){
match_object$offset_object = list()
# match_object$dev_credit = global_object$dev_credit
}
return(match_object)
}
global_object$match_object <- match_parcel_set(offset_pool_object = global_object$offset_pool_object,
global_object$dev_credit_to_use,
dev_weights,
global_params,
current_program_params,
intervention_vec = current_program_params$intervention_vec,
ind_available = global_object$index_object$ind_available[[region_ind]],
global_object$current_ecology,
decline_rates = global_object$decline_rates,
parcels$land_parcels,
yr,
time_horizon,
region_ind)  #perform the matching routine - i.e. find a matching development/offset set.
offset_pool_object = global_object$offset_pool_object
intervention_vec = current_program_params$intervention_vec
ind_available = global_object$index_object$ind_available[[region_ind]]
dev_credit = global_object$dev_credit
decline_rates = global_object$decline_rates
land_parcels = parcels$land_parcels
current_ecology = global_object$current_ecology
match_object = list()
match_object$match_flag = FALSE
current_pool_vals = offset_pool_object$parcel_vals_used
current_pool_indexes = offset_pool_object$parcel_indexes
parcel_num_remaining = length(ind_available)
current_match_pool = ind_available
current_dev_weights = dev_weights[current_match_pool]
current_dev_weights
lapply(current_dev_weights/sum(unlist(current_dev_weights))
)
current_dev_weights = lapply(seq_along(current_dev_weights), function(i) current_dev_weights[[i]]/sum(unlist(current_dev_weights)))
current_dev_weights
match_parcel_set <- function(offset_pool_object, dev_credit, dev_weights, global_params, current_program_params,
intervention_vec, ind_available, current_ecology, decline_rates_initial,
land_parcels, yr, time_horizon, region_ind){
match_object = list()
match_object$match_flag = FALSE
current_pool_vals = offset_pool_object$parcel_vals_used
current_pool_indexes = offset_pool_object$parcel_indexes
parcel_num_remaining = length(ind_available)
current_match_pool = ind_available
current_dev_weights = dev_weights[current_match_pool]
current_dev_weights = lapply(seq_along(current_dev_weights), function(i) current_dev_weights[[i]]/sum(unlist(current_dev_weights)))
if (parcel_num_remaining == 0){ # exit if no parcels remain
return(match_object)
}
dev_pool_object <- record_current_parcel_set(current_ecology[current_match_pool],
current_match_pool,
parcel_num_remaining,
yr,
region_ind) #record potential current development parcel attributes
dev_pool_object <- assess_current_pool(pool_object = dev_pool_object,
pool_type = 'devs',
calc_type = current_program_params$dev_calc_type,
cfacs_flag = current_program_params$dev_cfacs_flag,
adjust_cfacs_flag = current_program_params$adjust_dev_cfacs_flag,
offset_restoration_flag = current_program_params$offset_restoration_flag,
include_potential_developments = current_program_params$include_potential_developments_in_dev_calc,
include_potential_offsets = current_program_params$include_potential_offsets_in_dev_calc,
include_illegal_clearing = current_program_params$include_illegal_clearing_in_dev_calc,
time_horizon_type = 'future',
global_params,
current_program_params,
decline_rates_initial,
time_horizon,
yr)  #determine future development parcel attributes
current_match_vals_pool = dev_pool_object$parcel_vals_used
while( (match_object$match_flag == FALSE) & length(current_match_pool > 1) ){   #any potential parcel set match requires a minimum of two sites
if (current_program_params$development_selection_type == 'random'){
sample_ind = sample(seq_along(current_match_pool), size = 1)
} else if (current_program_params$development_selection_type == 'weighted'){
sample_ind = sample(seq_along(current_match_pool), size = 1, prob = current_dev_weights)
}
current_test_index = current_match_pool[sample_ind]
vals_to_match = current_match_vals_pool[[sample_ind]]
if (current_program_params$use_offset_bank == FALSE){
dev_ind = list_intersect(current_pool_indexes, current_test_index) #find and remove index that corresponds to potiential development index
match_pool_to_use = current_pool_indexes[-dev_ind$match_ind]
vals_to_use = current_pool_vals[-dev_ind$match_ind]
} else {
match_pool_to_use = current_pool_indexes  #if performing offset banking use any of the available banked offset pool
vals_to_use = current_pool_vals
}
match_object <- select_from_pool(match_type = 'offset',
match_procedure = 'euclidean',
current_pool = match_pool_to_use,
vals_to_use,
dev_credit,
dev_weights,
use_parcel_set_dev_credit = current_program_params$use_parcel_set_dev_credit,
offset_multiplier = current_program_params$offset_multiplier,
match_threshold = global_params$match_threshold,
vals_to_match_initial = vals_to_match,
current_program_params$offset_parcel_for_parcel,
dims_to_use = global_params$dims_to_use,
max_offset_parcel_num = global_params$max_offset_parcel_num,
yr) #perform matching routine
if (match_object$match_flag == FALSE){
inds_to_keep = which(lapply(seq_along(dev_pool_object$parcel_vals_used),
function(i) all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[i]], vals_to_match)) < 0) ) == TRUE)
current_match_pool = dev_pool_object$parcel_indexes[inds_to_keep]     #remove current potential development from potential pool
current_match_vals_pool = dev_pool_object$parcel_vals_used[inds_to_keep]
print(length(current_match_pool))
print(unlist(vals_to_match))
}
}
if (match_object$match_flag == TRUE){
dev_match_index = which(unlist(dev_pool_object$parcel_indexes) == current_test_index)
match_object$current_development_object = select_subset(dev_pool_object, unlist(dev_match_index))
subset_pool =  list_intersect(offset_pool_object$parcel_indexes, match_object$match_indexes)
offset_object <- select_subset(pool_object = offset_pool_object, subset_pool = subset_pool$match_ind)
match_object$offset_object = offset_object
} else if (match_object$match_flag == FALSE){
match_object$offset_object = list()
# match_object$dev_credit = global_object$dev_credit
}
return(match_object)
}
global_object$match_object <- match_parcel_set(offset_pool_object = global_object$offset_pool_object,
global_object$dev_credit_to_use,
dev_weights,
global_params,
current_program_params,
intervention_vec = current_program_params$intervention_vec,
ind_available = global_object$index_object$ind_available[[region_ind]],
global_object$current_ecology,
decline_rates = global_object$decline_rates,
parcels$land_parcels,
yr,
time_horizon,
region_ind)  #perform the matching routine - i.e. find a matching development/offset set.
match_object$match_flag
global_object = intialise_global_object(sim_group$global_params, sim_group$initial_ecology, sim_group$decline_rates_initial, sim_group$parcels)
global_object <- run_system(global_object, sim_group$global_params, sim_group$program_params_to_use, sim_group$decline_rates_initial, sim_group$parcels, sim_group$dev_weights)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_offsets_simulation.R', echo=TRUE)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_offsets_simulation.R', echo=TRUE)
library(abind)
library(pixmap)
source_folder = '~/Documents/R_Codes/Offsets_Working_Feb_3/'
output_folder = '~/Documents/offset_data/'
if (!file.exists(output_folder)){
dir.create(output_folder)
}
source(paste(source_folder, 'initialise_params.R', sep = '', collapse = ''))                              # functions to collate simulation outputs
source(paste(source_folder,'run_system_routines_modularised.R', sep = '', collapse = ''))                # functions to run simulation
source(paste(source_folder,'collate_routines.R', sep = '', collapse = ''))                                # functions to collate simulation outputs
source(paste(source_folder,'plot_routines.R', sep = '', collapse = ''))                                   # functions to plot collated outputs
collate_realisations = TRUE
plot_impacts = TRUE
save_realisations = FALSE
save_collated_realisations = FALSE
run_from_saved = FALSE                                   # run from previous data or run from newly generated ecology etc.
save_initial_conditions = FALSE                             # use this to run from simulated data (calculated at the initialisation of the code) or load data (eg from zonation etc)
data_type = 'simulated'                                  # use this to run from simulated data (FALSE) or load data (TRUE - eg data from zonation etc - this will need to be modified to fit the expected format)
write_movie = FALSE                                      # write evolving ecology to movie
show_movie = FALSE                                      # show output in movie form of evolving ecology
write_offset_layer = FALSE                                    # write layer containing all offset parcels to pdf
table_file = paste(output_folder, 'run_summary.csv', sep = '', collapse = '')
if (run_from_saved == TRUE){
parcels <- readRDS(paste(source_folder, 'parcels.rds', sep = '', collapse = ''))
initial_ecology <- readRDS(paste(source_folder, 'initial_ecology.rds', sep = '', collapse = ''))
decline_rates_initial <- readRDS(paste(source_folder, 'decline_rates_initial.rds', sep = '', collapse = ''))
global_params <- readRDS(paste(source_folder, 'global_params.rds', sep = '', collapse = ''))
} else {
global_params <- initialise_global_params()
if (data_type == 'grassland'){
parcels <- initialise_parcels_from_data(data_folder = "~/offset_data/grassland_data/")
initial_ecology <- initialise_ecology_from_grassland_data(filename =  "~/Desktop/grassland_data/hab.map.master.zo1.pgm", land_parcels = parcels$land_parcels, eco_dims = global_params$eco_dims)
dev_weights = list()
} else if (data_type == 'hunter'){
data_folder = paste(path.expand('~'), '/offset_data/Hunter/data/', sep = '', collapse = '')
parcels <- initialise_parcels_from_data(data_folder, data_type)
initial_ecology <- initialise_ecology_from_hunter_data(data_folder,
land_parcels = parcels$land_parcels,
eco_dims = global_params$eco_dims)
dev_weights <- readRDS(paste(data_folder, 'mining_raster.rds', sep = '', collapse = ''))
dev_weights <- stackApply(dev_weights, indices = rep(1, dim(dev_weights)[3]), fun = sum)
dev_weights_array <- raster_to_array(dev_weights)
dev_weights = lapply(seq_along(land_parcels), function(i) sum(dev_weights_array[ land_parcels[[i]] ])/sum(dev_weights_array))
} else if (data_type == 'simulated'){
parcels <- initialise_shape_parcels(global_params)
initial_ecology <- initialise_ecology(global_params, land_parcels = parcels$land_parcels) #generate initial ecology as randomised landscape divided into land parcels where each parcel is a cell composed of numerical elements
dev_weights = list()
}
decline_rates_initial <- initialise_decline_rates(parcels,
global_params$sample_decline_rate,
global_params$mean_decline_rates,
global_params$decline_rate_std,
eco_dims = global_params$eco_dims)       # set up array of decline rates that are eassociated with each cell
if (parcels$region_num > 1){
regional_program_params_group = get_regional_params()
} else {
regional_program_params_group = list()
}
program_params_to_test <- initialise_program_params() # list all program combinations to test
program_combs <- generate_program_combs(program_params_to_test)  #generate all combinations of offset programs
policy_num = dim(program_combs)[1] #how many combinations there are in total
program_params_group = generate_program_params_group(policy_num, program_combs, program_params_to_test)
}
if (save_initial_conditions == TRUE){
saveRDS(parcels, paste('parcels.rds', sep = '', collapse = ''))
saveRDS(initial_ecology, paste('initial_ecology.rds', sep = '', collapse = ''))
saveRDS(decline_rates_initial, paste('decline_rates_initial.rds', sep = '', collapse = ''))
saveRDS(global_params, paste('global_params.rds', sep = '', collapse = ''))
saveRDS(program_params, paste('program_params_group.rds', sep = '', collapse = ''))
}
crs = detectCores(all.tests = FALSE, logical = TRUE)
cl<-makeCluster(crs)        #allow parallel processing on n = 4 processors
registerDoParallel(cl)
print(paste('testing ', policy_num, ' combinations on ', crs, ' cores'))
strt<-Sys.time()
program_params_to_use = append(program_params_group[policy_ind], regional_program_params_group)
sim_group = list(global_params, program_params_to_use, initial_ecology, decline_rates_initial, parcels, dev_weights)
names(sim_group) = c('global_params', 'program_params_to_use', 'initial_ecology', 'decline_rates_initial', 'parcels', 'dev_weights')
global_params$realisation_num
global_object = intialise_global_object(sim_group$global_params, sim_group$initial_ecology, sim_group$decline_rates_initial, sim_group$parcels)
global_object <- run_system(global_object, sim_group$global_params, sim_group$program_params_to_use, sim_group$decline_rates_initial, sim_group$parcels, sim_group$dev_weights)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_offsets_simulation.R', echo=TRUE)
global_object = intialise_global_object(sim_group$global_params, sim_group$initial_ecology, sim_group$decline_rates_initial, sim_group$parcels)
global_object <- run_system(global_object, sim_group$global_params, sim_group$program_params_to_use, sim_group$decline_rates_initial, sim_group$parcels, sim_group$dev_weights)
source(paste(source_folder, 'initialise_params.R', sep = '', collapse = ''))                              # functions to collate simulation outputs
source(paste(source_folder,'run_system_routines_modularised.R', sep = '', collapse = ''))                # functions to run simulation
source(paste(source_folder,'collate_routines.R', sep = '', collapse = ''))                                # functions to collate simulation outputs
source(paste(source_folder,'plot_routines.R', sep = '', collapse = ''))                                   # functions to plot collated outputs
global_object = intialise_global_object(sim_group$global_params, sim_group$initial_ecology, sim_group$decline_rates_initial, sim_group$parcels)
global_object <- run_system(global_object, sim_group$global_params, sim_group$program_params_to_use, sim_group$decline_rates_initial, sim_group$parcels, sim_group$dev_weights)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_offsets_simulation.R', echo=TRUE)
collate_realisatons
collated_realisations <- run_collate_routines(realisations,
sim_group$global_params,
sim_group$program_params_to_use,
use_cfac_type_in_sim = FALSE,
sim_group$decline_rates_initial,
sim_group$parcels,
sim_group$initial_ecology) #take simulation ouputs and calculate gains and losses
plot_impact_set(collated_realisations,
current_program_params = sim_group$program_params_to_use,
site_impact_plot_lims = c(0, 1e4),
program_impact_plot_lims = c(-6e5, 6e5),
landscape_impact_plot_lims = c(-6e5, 6e5),
sets_to_plot = 50,
eco_ind = 1,
lwd_vec = c(3, 0.5),
edge_title = policy_type,
time_steps = 50,
offset_bank,
sim_group$parcels$land_parcel_num)
plot_impact_set(collated_realisations,
current_program_params = sim_group$program_params_to_use,
site_plot_lims = c(0, 1e4),
program_plot_lims = c(-6e5, 6e5),
landscape_plot_lims = c(-6e5, 6e5),
sets_to_plot = 50,
eco_ind = 1,
lwd_vec = c(3, 0.5),
edge_title = policy_type,
time_steps = 50,
offset_bank,
sim_group$parcels$land_parcel_num)
plot_impact_set(collated_realisations,
current_program_params = sim_group$program_params_to_use,
site_plot_lims = c(0, 1e4),
program_plot_lims = c(-6e5, 6e5),
landscape_plot_lims = c(-6e5, 6e5),
sets_to_plot = 50,
eco_ind = 1,
lwd_vec = c(3, 0.5),
edge_title = policy_type,
time_steps = 50,
offset_bank = FALSE,
sim_group$parcels$land_parcel_num)
plot_impact_set(collated_realisations,
current_program_params = sim_group$program_params_to_use,
site_plot_lims = c(0, 1e4),
program_plot_lims = c(-6e5, 6e5),
landscape_plot_lims = c(-6e5, 6e5),
sets_to_plot = 50,
eco_ind = 1,
lwd_vec = c(3, 0.5),
edge_title = '',
time_steps = 50,
offset_bank = FALSE,
sim_group$parcels$land_parcel_num)
plot_impact_set(collated_realisations,
current_program_params = sim_group$program_params_to_use,
site_plot_lims = c(-1e4, 1e4),
program_plot_lims = c(-6e5, 6e5),
landscape_plot_lims = c(-6e5, 6e5),
sets_to_plot = 50,
eco_ind = 1,
lwd_vec = c(3, 0.5),
edge_title = policy_type,
time_steps = 50,
offset_bank,
sim_group$parcels$land_parcel_num)
setup_sub_plots(nx = 3, ny = 1, x_space = 5, y_space = 5)
plot_impact_set(collated_realisations,
current_program_params = sim_group$program_params_to_use,
site_plot_lims = c(-1e4, 1e4),
program_plot_lims = c(-6e5, 6e5),
landscape_plot_lims = c(-6e5, 6e5),
sets_to_plot = 50,
eco_ind = 1,
lwd_vec = c(3, 0.5),
edge_title = policy_type,
time_steps = 50,
offset_bank = sim_group$program_params_to_use[[1]]$use_offset_bank,
sim_group$parcels$land_parcel_num)
setup_sub_plots(nx = 3, ny = 1, x_space = 5, y_space = 5)
plot_impact_set(collated_realisations,
current_program_params = sim_group$program_params_to_use,
site_plot_lims = c(-1e4, 1e4),
program_plot_lims = c(-6e5, 6e5),
landscape_plot_lims = c(-6e5, 6e5),
sets_to_plot = 50,
eco_ind = 1,
lwd_vec = c(3, 0.5),
edge_title = sim_characteristics,
time_steps = 50,
offset_bank = sim_group$program_params_to_use[[1]]$use_offset_bank,
sim_group$parcels$land_parcel_num)
polocy_num
policy_num
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_offsets_simulation.R', echo=TRUE)
getwd
getwd()
setwd('~/Documents/R_Codes/Offsets_Working_Feb_3/')
output_folder = paste(pathexpand('~'), '/offset_data/', sep = '', collapse = '')
path.expand('~')
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_offsets_simulation.R', echo=TRUE)
