sample_ind = sample(x = (1:length(current_match_pool)), size = 1)
current_test_index = current_match_pool[sample_ind]
}
vals_to_match = current_match_vals_pool[[sample_ind]]
if (current_program_params$use_offset_bank == FALSE){
dev_ind = list_intersect(current_pool_indexes, current_test_index) #find and remove index that corresponds to potiential development index
match_pool_to_use = current_pool_indexes[-dev_ind$match_ind]
vals_to_use = current_pool_vals[-dev_ind$match_ind]
} else {
match_pool_to_use = current_pool_indexes  #if performing offset banking use any of the available banked offset pool
vals_to_use = current_pool_vals
}
match_object <- select_from_pool(match_type = 'offset',
match_procedure = 'euclidean',
current_pool = match_pool_to_use,
vals_to_use,
dev_credit,
use_parcel_set_dev_credit = current_program_params$use_parcel_set_dev_credit,
offset_multiplier = current_program_params$offset_multiplier,
match_threshold = global_params$match_threshold,
vals_to_match_initial = vals_to_match,
current_program_params$offset_parcel_for_parcel,
dims_to_use = global_params$dims_to_use,
max_offset_parcel_num = global_params$max_offset_parcel_num,
yr) #perform matching routine
if (match_object$match_flag == FALSE){
#inds_to_reject = which(unlist(dev_pool_object$parcel_vals_used) >= unlist(vals_to_match))
inds_to_reject = which(lapply(seq_along(dev_pool_object$parcel_vals_used),
function(i) all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[i]], vals_to_match)) > 0)) == TRUE)
current_match_pool = dev_pool_object$parcel_indexes[-inds_to_reject]     #remove current potential development from potential pool
current_match_vals_pool = dev_pool_object$parcel_vals_used[-inds_to_reject]
print(length(current_match_pool))
print(unlist(vals_to_match))
}
}
if (match_object$match_flag == TRUE){
dev_match_index = which(unlist(dev_pool_object$parcel_indexes) == current_test_index)
match_object$current_development_object = select_subset(dev_pool_object, unlist(dev_match_index))
subset_pool =  list_intersect(offset_pool_object$parcel_indexes, match_object$match_indexes)
offset_object <- select_subset(pool_object = offset_pool_object, subset_pool = subset_pool$match_ind)
match_object$offset_object = offset_object
} else if (match_object$match_flag == FALSE){
match_object$offset_object = list()
# match_object$dev_credit = global_object$dev_credit
}
return(match_object)
}
match_object <- match_parcel_set(offset_pool_object = global_object$offset_pool_object,
global_object$dev_credit_to_use,
global_params,
current_program_params,
intervention_vec = current_program_params$intervention_vec,
ind_available = global_object$index_object$ind_available[[region_ind]],
global_object$current_ecology,
decline_rates = global_object$decline_rates,
parcels$land_parcels,
yr,
time_horizon,
region_ind)  #perform the matching routine - i.e. find a matching development/offset set.
offset_pool_object = global_object$offset_pool_object
intervention_vec = current_program_params$intervention_vec
ind_available = global_object$index_object$ind_available[[region_ind]]
dev_credit = global_object$dev_credit
decline_rates = global_object$decline_rates
land_parcels = parcels$land_parcels
current_ecology = global_object$current_ecology
match_object = list()
match_object$match_flag = FALSE
current_pool_vals = offset_pool_object$parcel_vals_used
current_pool_indexes = offset_pool_object$parcel_indexes
parcel_num_remaining = length(ind_available)
current_match_pool = ind_available
if (parcel_num_remaining == 0){ # exit if no parcels remain
return(match_object)
}
dev_pool_object <- record_current_parcel_set(current_ecology[current_match_pool],
current_match_pool,
parcel_num_remaining,
yr,
region_ind) #record potential current development parcel attributes
dev_pool_object <- assess_current_pool(pool_object = dev_pool_object,
pool_type = 'devs',
calc_type = current_program_params$dev_calc_type,
cfacs_flag = current_program_params$dev_cfacs_flag,
adjust_cfacs_flag = current_program_params$adjust_dev_cfacs_flag,
offset_restoration_flag = current_program_params$offset_restoration_flag,
include_potential_developments = current_program_params$include_potential_developments_in_dev_calc,
include_potential_offsets = current_program_params$include_potential_offsets_in_dev_calc,
include_illegal_clearing = current_program_params$include_illegal_clearing_in_dev_calc,
time_horizon_type = 'future',
global_params,
current_program_params,
decline_rates,
decline_rates_initial,
time_horizon,
yr)  #determine future development parcel attributes
current_match_vals_pool = dev_pool_object$parcel_vals_used
if (current_program_params$development_selection_type == 'random'){
sample_ind = sample(x = (1:length(current_match_pool)), size = 1)
current_test_index = current_match_pool[sample_ind]
}
vals_to_match = current_match_vals_pool[[sample_ind]]
if (current_program_params$use_offset_bank == FALSE){
dev_ind = list_intersect(current_pool_indexes, current_test_index) #find and remove index that corresponds to potiential development index
match_pool_to_use = current_pool_indexes[-dev_ind$match_ind]
vals_to_use = current_pool_vals[-dev_ind$match_ind]
} else {
match_pool_to_use = current_pool_indexes  #if performing offset banking use any of the available banked offset pool
vals_to_use = current_pool_vals
}
match_object <- select_from_pool(match_type = 'offset',
match_procedure = 'euclidean',
current_pool = match_pool_to_use,
vals_to_use,
dev_credit,
use_parcel_set_dev_credit = current_program_params$use_parcel_set_dev_credit,
offset_multiplier = current_program_params$offset_multiplier,
match_threshold = global_params$match_threshold,
vals_to_match_initial = vals_to_match,
current_program_params$offset_parcel_for_parcel,
dims_to_use = global_params$dims_to_use,
max_offset_parcel_num = global_params$max_offset_parcel_num,
yr) #perform matching routine
if (match_object$match_flag == FALSE){
#inds_to_reject = which(unlist(dev_pool_object$parcel_vals_used) >= unlist(vals_to_match))
inds_to_reject = which(lapply(seq_along(dev_pool_object$parcel_vals_used),
function(i) all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[i]], vals_to_match)) > 0)) == TRUE)
current_match_pool = dev_pool_object$parcel_indexes[-inds_to_reject]     #remove current potential development from potential pool
current_match_vals_pool = dev_pool_object$parcel_vals_used[-inds_to_reject]
print(length(current_match_pool))
print(unlist(vals_to_match))
}
inds_to_reject
current_match_vals_pool
simplify2array(current_match_vals_pool)
current_match_vals_pool
vals_to_match
yr
match_object <- match_parcel_set(offset_pool_object = global_object$offset_pool_object,
global_object$dev_credit_to_use,
global_params,
current_program_params,
intervention_vec = current_program_params$intervention_vec,
ind_available = global_object$index_object$ind_available[[region_ind]],
global_object$current_ecology,
decline_rates = global_object$decline_rates,
parcels$land_parcels,
yr,
time_horizon,
region_ind)  #perform the matching routine - i.e. find a matching development/offset set.
offset_pool_object = global_object$offset_pool_object
intervention_vec = current_program_params$intervention_vec
ind_available = global_object$index_object$ind_available[[region_ind]]
dev_credit = global_object$dev_credit
decline_rates = global_object$decline_rates
land_parcels = parcels$land_parcels
current_ecology = global_object$current_ecology
match_object = list()
match_object$match_flag = FALSE
current_pool_vals = offset_pool_object$parcel_vals_used
current_pool_indexes = offset_pool_object$parcel_indexes
parcel_num_remaining = length(ind_available)
current_match_pool = ind_available
if (parcel_num_remaining == 0){ # exit if no parcels remain
return(match_object)
}
dev_pool_object <- record_current_parcel_set(current_ecology[current_match_pool],
current_match_pool,
parcel_num_remaining,
yr,
region_ind) #record potential current development parcel attributes
dev_pool_object <- assess_current_pool(pool_object = dev_pool_object,
pool_type = 'devs',
calc_type = current_program_params$dev_calc_type,
cfacs_flag = current_program_params$dev_cfacs_flag,
adjust_cfacs_flag = current_program_params$adjust_dev_cfacs_flag,
offset_restoration_flag = current_program_params$offset_restoration_flag,
include_potential_developments = current_program_params$include_potential_developments_in_dev_calc,
include_potential_offsets = current_program_params$include_potential_offsets_in_dev_calc,
include_illegal_clearing = current_program_params$include_illegal_clearing_in_dev_calc,
time_horizon_type = 'future',
global_params,
current_program_params,
decline_rates,
decline_rates_initial,
time_horizon,
yr)  #determine future development parcel attributes
current_match_vals_pool = dev_pool_object$parcel_vals_used
if (current_program_params$development_selection_type == 'random'){
sample_ind = sample(x = (1:length(current_match_pool)), size = 1)
current_test_index = current_match_pool[sample_ind]
}
vals_to_match = current_match_vals_pool[[sample_ind]]
if (current_program_params$use_offset_bank == FALSE){
dev_ind = list_intersect(current_pool_indexes, current_test_index) #find and remove index that corresponds to potiential development index
match_pool_to_use = current_pool_indexes[-dev_ind$match_ind]
vals_to_use = current_pool_vals[-dev_ind$match_ind]
} else {
match_pool_to_use = current_pool_indexes  #if performing offset banking use any of the available banked offset pool
vals_to_use = current_pool_vals
}
match_object <- select_from_pool(match_type = 'offset',
match_procedure = 'euclidean',
current_pool = match_pool_to_use,
vals_to_use,
dev_credit,
use_parcel_set_dev_credit = current_program_params$use_parcel_set_dev_credit,
offset_multiplier = current_program_params$offset_multiplier,
match_threshold = global_params$match_threshold,
vals_to_match_initial = vals_to_match,
current_program_params$offset_parcel_for_parcel,
dims_to_use = global_params$dims_to_use,
max_offset_parcel_num = global_params$max_offset_parcel_num,
yr) #perform matching routine
if (current_program_params$development_selection_type == 'random'){
sample_ind = sample(x = (1:length(current_match_pool)), size = 1)
current_test_index = current_match_pool[sample_ind]
}
vals_to_match = current_match_vals_pool[[sample_ind]]
if (current_program_params$use_offset_bank == FALSE){
dev_ind = list_intersect(current_pool_indexes, current_test_index) #find and remove index that corresponds to potiential development index
match_pool_to_use = current_pool_indexes[-dev_ind$match_ind]
vals_to_use = current_pool_vals[-dev_ind$match_ind]
} else {
match_pool_to_use = current_pool_indexes  #if performing offset banking use any of the available banked offset pool
vals_to_use = current_pool_vals
}
match_object <- select_from_pool(match_type = 'offset',
match_procedure = 'euclidean',
current_pool = match_pool_to_use,
vals_to_use,
dev_credit,
use_parcel_set_dev_credit = current_program_params$use_parcel_set_dev_credit,
offset_multiplier = current_program_params$offset_multiplier,
match_threshold = global_params$match_threshold,
vals_to_match_initial = vals_to_match,
current_program_params$offset_parcel_for_parcel,
dims_to_use = global_params$dims_to_use,
max_offset_parcel_num = global_params$max_offset_parcel_num,
yr) #perform matching routine
if (match_object$match_flag == FALSE){
#inds_to_reject = which(unlist(dev_pool_object$parcel_vals_used) >= unlist(vals_to_match))
inds_to_reject = which(lapply(seq_along(dev_pool_object$parcel_vals_used),
function(i) all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[i]], vals_to_match)) > 0)) == TRUE)
current_match_pool = dev_pool_object$parcel_indexes[-inds_to_reject]     #remove current potential development from potential pool
current_match_vals_pool = dev_pool_object$parcel_vals_used[-inds_to_reject]
print(length(current_match_pool))
print(unlist(vals_to_match))
}
inds_to_reject
length(inds_to_reject)
length(dev_pool_object$parcel_vals_used)
1358-244
current_match_vals_pool
lapply(seq_along(current_match_vals_pool),
function(i) all(unlist(subtract_nested_lists(current_match_vals_pool[[i]], vals_to_match)) > 0)) == TRUE)
lapply(seq_along(current_match_vals_pool),
function(i) all(unlist(subtract_nested_lists(current_match_vals_pool[[i]], vals_to_match)) > 0) == TRUE)
unlist(lapply(seq_along(current_match_vals_pool),
function(i) all(unlist(subtract_nested_lists(current_match_vals_pool[[i]], vals_to_match)) > 0) == TRUE))
vtm = vals_to_match
inds_to_reject = which(lapply(seq_along(dev_pool_object$parcel_vals_used),
function(i) all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[i]], vals_to_match)) > 0)) == TRUE)
current_match_pool = dev_pool_object$parcel_indexes[-inds_to_reject]     #remove current potential development from potential pool
current_match_vals_pool = dev_pool_object$parcel_vals_used[-inds_to_reject]
print(length(current_match_pool))
print(unlist(vals_to_match))
current_program_params$use_offset_bank
if (current_program_params$development_selection_type == 'random'){
sample_ind = sample(x = (1:length(current_match_pool)), size = 1)
current_test_index = current_match_pool[sample_ind]
}
vals_to_match = current_match_vals_pool[[sample_ind]]
vals_to_match
vtm
subtract_nested_lists(vtm, vals_to_match)
all(unlist(subtract_nested_lists(vtm, vals_to_match)) > 0)) == TRUE)
all(unlist(subtract_nested_lists(vtm, vals_to_match)) > 0) == TRUE)
all(unlist(subtract_nested_lists(vtm, vals_to_match)) > 0))
all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[i]], vals_to_match)) > 0)
all(unlist(subtract_nested_lists(vtm, vals_to_match)) > 0)
dev_pool_object$parcel_vals_used[[i]]
dev_pool_object$parcel_vals_used
simplify2array(dev_pool_object$parcel_vals_used)
simplify2array(dev_pool_object$parcel_vals_used, ncol = 2)
simplify2array(dev_pool_object$parcel_vals_used)
a = simplify2array(dev_pool_object$parcel_vals_used)
a
min(a)
a = simplify2array(dev_pool_object$parcel_vals_used, higher = TRUE)
a
a[1]
a[2]
a = simplify2array(simplify2array(dev_pool_object$parcel_vals_used, higher = TRUE))
a
a[1]
current_match_pool
current_match_pool = unlist(current_match_pool[1:10])
dev_pool_object <- record_current_parcel_set(current_ecology[current_match_pool],
current_match_pool,
parcel_num_remaining,
yr,
region_ind) #record potential current development parcel attributes
dev_pool_object <- assess_current_pool(pool_object = dev_pool_object,
pool_type = 'devs',
calc_type = current_program_params$dev_calc_type,
cfacs_flag = current_program_params$dev_cfacs_flag,
adjust_cfacs_flag = current_program_params$adjust_dev_cfacs_flag,
offset_restoration_flag = current_program_params$offset_restoration_flag,
include_potential_developments = current_program_params$include_potential_developments_in_dev_calc,
include_potential_offsets = current_program_params$include_potential_offsets_in_dev_calc,
include_illegal_clearing = current_program_params$include_illegal_clearing_in_dev_calc,
time_horizon_type = 'future',
global_params,
current_program_params,
decline_rates,
decline_rates_initial,
time_horizon,
yr)  #determine future development parcel attributes
current_match_vals_pool = dev_pool_object$parcel_vals_used
current_match_vals_pool
if (current_program_params$development_selection_type == 'random'){
sample_ind = sample(x = (1:length(current_match_pool)), size = 1)
current_test_index = current_match_pool[sample_ind]
}
vals_to_match = current_match_vals_pool[[sample_ind]]
if (current_program_params$use_offset_bank == FALSE){
dev_ind = list_intersect(current_pool_indexes, current_test_index) #find and remove index that corresponds to potiential development index
match_pool_to_use = current_pool_indexes[-dev_ind$match_ind]
vals_to_use = current_pool_vals[-dev_ind$match_ind]
} else {
match_pool_to_use = current_pool_indexes  #if performing offset banking use any of the available banked offset pool
vals_to_use = current_pool_vals
}
match_object <- select_from_pool(match_type = 'offset',
match_procedure = 'euclidean',
current_pool = match_pool_to_use,
vals_to_use,
dev_credit,
use_parcel_set_dev_credit = current_program_params$use_parcel_set_dev_credit,
offset_multiplier = current_program_params$offset_multiplier,
match_threshold = global_params$match_threshold,
vals_to_match_initial = vals_to_match,
current_program_params$offset_parcel_for_parcel,
dims_to_use = global_params$dims_to_use,
max_offset_parcel_num = global_params$max_offset_parcel_num,
yr) #perform matching routine
if (match_object$match_flag == FALSE){
#inds_to_reject = which(unlist(dev_pool_object$parcel_vals_used) >= unlist(vals_to_match))
inds_to_reject = which(lapply(seq_along(dev_pool_object$parcel_vals_used),
function(i) all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[i]], vals_to_match)) > 0) ) == TRUE)
current_match_pool = dev_pool_object$parcel_indexes[-inds_to_reject]     #remove current potential development from potential pool
current_match_vals_pool = dev_pool_object$parcel_vals_used[-inds_to_reject]
print(length(current_match_pool))
print(unlist(vals_to_match))
}
inds_to_reject
current_match_pool = unlist(current_match_pool[1:10])
dev_pool_object <- record_current_parcel_set(current_ecology[current_match_pool],
current_match_pool,
parcel_num_remaining,
yr,
region_ind) #record potential current development parcel attributes
dev_pool_object <- assess_current_pool(pool_object = dev_pool_object,
pool_type = 'devs',
calc_type = current_program_params$dev_calc_type,
cfacs_flag = current_program_params$dev_cfacs_flag,
adjust_cfacs_flag = current_program_params$adjust_dev_cfacs_flag,
offset_restoration_flag = current_program_params$offset_restoration_flag,
include_potential_developments = current_program_params$include_potential_developments_in_dev_calc,
include_potential_offsets = current_program_params$include_potential_offsets_in_dev_calc,
include_illegal_clearing = current_program_params$include_illegal_clearing_in_dev_calc,
time_horizon_type = 'future',
global_params,
current_program_params,
decline_rates,
decline_rates_initial,
time_horizon,
yr)  #determine future development parcel attributes
current_match_vals_pool = dev_pool_object$parcel_vals_used
if (current_program_params$development_selection_type == 'random'){
sample_ind = sample(x = (1:length(current_match_pool)), size = 1)
current_test_index = current_match_pool[sample_ind]
}
vals_to_match = current_match_vals_pool[[sample_ind]]
if (current_program_params$use_offset_bank == FALSE){
dev_ind = list_intersect(current_pool_indexes, current_test_index) #find and remove index that corresponds to potiential development index
match_pool_to_use = current_pool_indexes[-dev_ind$match_ind]
vals_to_use = current_pool_vals[-dev_ind$match_ind]
} else {
match_pool_to_use = current_pool_indexes  #if performing offset banking use any of the available banked offset pool
vals_to_use = current_pool_vals
}
match_object <- select_from_pool(match_type = 'offset',
match_procedure = 'euclidean',
current_pool = match_pool_to_use,
vals_to_use,
dev_credit,
use_parcel_set_dev_credit = current_program_params$use_parcel_set_dev_credit,
offset_multiplier = current_program_params$offset_multiplier,
match_threshold = global_params$match_threshold,
vals_to_match_initial = vals_to_match,
current_program_params$offset_parcel_for_parcel,
dims_to_use = global_params$dims_to_use,
max_offset_parcel_num = global_params$max_offset_parcel_num,
yr) #perform matching routine
if (match_object$match_flag == FALSE){
#inds_to_reject = which(unlist(dev_pool_object$parcel_vals_used) >= unlist(vals_to_match))
inds_to_reject = which(lapply(seq_along(dev_pool_object$parcel_vals_used),
function(i) all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[i]], vals_to_match)) > 0) ) == TRUE)
#current_match_pool = dev_pool_object$parcel_indexes[-inds_to_reject]     #remove current potential development from potential pool
#current_match_vals_pool = dev_pool_object$parcel_vals_used[-inds_to_reject]
print(length(current_match_pool))
print(unlist(vals_to_match))
}
inds_to_reject
current_match_pool
dev_pool_object$parcel_vals_used
unlist(dev_pool_object$parcel_vals_used, recursive = FALSE)
dev_pool_object$parcel_vals_used
vals_to_match
inds_to_reject
inds_to_reject = which(lapply(seq_along(dev_pool_object$parcel_vals_used),
function(i) all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[i]], vals_to_match)) >= 0) ) == TRUE)
inds_to_reject
dev_pool_object$parcel_indexes[-inds_to_reject]
dev_pool_object$parcel_indexes
dev_pool_object$parcel_indexes[-inds_to_reject]
dev_pool_object$parcel_vals_used[-inds_to_reject]
vals_to_match
inds_to_reject
dev_pool_object$parcel_vals_used[[4]]
dev_pool_object$parcel_vals_used[[8]]
subtract_nested_lists(dev_pool_object$parcel_vals_used[[8]], vals_to_match)
all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[8]], vals_to_match)) >= 0)
which(lapply(seq_along(dev_pool_object$parcel_vals_used),
function(i) all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[i]], vals_to_match)) < 0) ) == TRUE)
match_object = list()
match_object$match_flag = FALSE
current_pool_vals = offset_pool_object$parcel_vals_used
current_pool_indexes = offset_pool_object$parcel_indexes
parcel_num_remaining = length(ind_available)
current_match_pool = ind_available
if (parcel_num_remaining == 0){ # exit if no parcels remain
return(match_object)
}
dev_pool_object <- record_current_parcel_set(current_ecology[current_match_pool],
current_match_pool,
parcel_num_remaining,
yr,
region_ind) #record potential current development parcel attributes
dev_pool_object <- assess_current_pool(pool_object = dev_pool_object,
pool_type = 'devs',
calc_type = current_program_params$dev_calc_type,
cfacs_flag = current_program_params$dev_cfacs_flag,
adjust_cfacs_flag = current_program_params$adjust_dev_cfacs_flag,
offset_restoration_flag = current_program_params$offset_restoration_flag,
include_potential_developments = current_program_params$include_potential_developments_in_dev_calc,
include_potential_offsets = current_program_params$include_potential_offsets_in_dev_calc,
include_illegal_clearing = current_program_params$include_illegal_clearing_in_dev_calc,
time_horizon_type = 'future',
global_params,
current_program_params,
decline_rates,
decline_rates_initial,
time_horizon,
yr)  #determine future development parcel attributes
current_match_vals_pool = dev_pool_object$parcel_vals_used
while( (match_object$match_flag == FALSE) & length(current_match_pool > 0) ){
if (current_program_params$development_selection_type == 'random'){
sample_ind = sample(x = (1:length(current_match_pool)), size = 1)
current_test_index = current_match_pool[sample_ind]
}
vals_to_match = current_match_vals_pool[[sample_ind]]
if (current_program_params$use_offset_bank == FALSE){
dev_ind = list_intersect(current_pool_indexes, current_test_index) #find and remove index that corresponds to potiential development index
match_pool_to_use = current_pool_indexes[-dev_ind$match_ind]
vals_to_use = current_pool_vals[-dev_ind$match_ind]
} else {
match_pool_to_use = current_pool_indexes  #if performing offset banking use any of the available banked offset pool
vals_to_use = current_pool_vals
}
match_object <- select_from_pool(match_type = 'offset',
match_procedure = 'euclidean',
current_pool = match_pool_to_use,
vals_to_use,
dev_credit,
use_parcel_set_dev_credit = current_program_params$use_parcel_set_dev_credit,
offset_multiplier = current_program_params$offset_multiplier,
match_threshold = global_params$match_threshold,
vals_to_match_initial = vals_to_match,
current_program_params$offset_parcel_for_parcel,
dims_to_use = global_params$dims_to_use,
max_offset_parcel_num = global_params$max_offset_parcel_num,
yr) #perform matching routine
if (match_object$match_flag == FALSE){
#inds_to_reject = which(unlist(dev_pool_object$parcel_vals_used) >= unlist(vals_to_match))
inds_to_keep = which(lapply(seq_along(dev_pool_object$parcel_vals_used),
function(i) all(unlist(subtract_nested_lists(dev_pool_object$parcel_vals_used[[i]], vals_to_match)) < 0) ) == TRUE)
current_match_pool = dev_pool_object$parcel_indexes[inds_to_keep]     #remove current potential development from potential pool
current_match_vals_pool = dev_pool_object$parcel_vals_used[inds_to_keep]
print(length(current_match_pool))
print(unlist(vals_to_match))
}
}
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs_with_regions.R', echo=TRUE)
strt<-Sys.time()
current_program_param_inds = unlist(program_combs[comb_ind, ])
current_program <- generate_current_program(program_params[[2]], current_program_param_inds) #write current program as a list
global_params$program_params[[1]] <- collate_current_program(current_program, global_params)  #setup flags for cfacs, cfac adjustment etc.
global_object <- run_system(global_object, global_object$global_params, global_object$decline_rates, global_object$parcels)
source('~/Documents/R_Codes/Offsets_Working_Feb_3/run_program_combs_with_regions.R', echo=TRUE)
